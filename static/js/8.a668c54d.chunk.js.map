{"version":3,"sources":["../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread.js","../node_modules/react-use-gesture/dist/react-use-gesture.esm.js"],"names":["__webpack_require__","d","__webpack_exports__","_objectSpread","_defineProperty__WEBPACK_IMPORTED_MODULE_0__","target","i","arguments","length","source","ownKeys","Object","keys","getOwnPropertySymbols","concat","filter","sym","getOwnPropertyDescriptor","enumerable","forEach","key","useGesture","GestureFlag","react__WEBPACK_IMPORTED_MODULE_0__","react__WEBPACK_IMPORTED_MODULE_0___default","n","_extends","assign","prototype","hasOwnProperty","call","apply","this","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_objectWithoutPropertiesLoose","excluded","sourceKeys","indexOf","noop","chainFns","_len","fns","Array","_key","_len2","args","_key2","fn","addV","v1","v2","map","v","subV","setListeners","add","el","listeners","options","action","_ref","type","addListeners","removeListeners","getModifierKeys","event","shiftKey","altKey","metaKey","ctrlKey","getWheelEventData","values","deltaX","deltaY","getPointerEventData","touches","buttons","changedTouches","touchEvents","_ref2","clientX","clientY","down","getTwoTouchesEventData","dx","dy","Math","hypot","atan2","PI","origin","calculateVelocity","diff","delta_t","len","calculateVelocities","fill","calculateDistance","delta","calculateDirection","mappedKeys","drag","stateKey","handlerKey","pinch","move","scroll","wheel","hover","defaultConfig","domTarget","undefined","passive","capture","pointerEvents","window","transform","x","_x","y","_y","enabled","initialCommon","currentTarget","pointerId","velocities","initial","previous","local","lastLocal","first","last","active","time","cancel","canceled","memo","initialCoordinates","xy","vxvy","velocity","distance","direction","initialState","shared","hovering","scrolling","wheeling","dragging","moving","pinching","da","vdva","turns","genericEndState","Recognizer","gestureKey","controller","_this","isEnabled","config","setTimeout","callback","ms","_window","timeouts","clearTimeout","getState","state","getSharedState","pointerEventsEnabled","getTransformConfig","addWindowListeners","removeWindowListeners","updateState","sharedState","gestureState","gestureFlag","getStartState","timeStamp","CoordinatesRecognizer","_Recognizer","getKinematics","_state$time","_calculateAllKinemati","calculateAllKinematics","DragRecognizer","_CoordinatesRecognize","onStart","_getPointerEventData","rest","setPointerCapture","dragListeners","onChange","onEnd","startState","onCancel","OnStart","_this$getState","_getPointerEventData2","kinematics","OnChange","releasePointerCapture","OnEnd","requestAnimationFrame","getEventBindings","ScrollRecognizer","_getScrollEventData","_event$currentTarget","scrollX","scrollY","scrollLeft","scrollTop","getScrollEventData","WheelRecognizer","_getWheelEventData","eventValues","MoveRecognizer","HoverRecognizer","fireGestureHandler","DistanceAngleRecognizer","a","diff_d","diff_a","newTurns","abs","sign","PinchRecognizer","_DistanceAngleRecogni","_getTwoTouchesEventDa","_getTwoTouchesEventDa2","PinchWheelRecognizer","preventDefault","SCALE_FACTOR","PinchWebKitGestureRecognizer","scale","rotation","updateTouchData","GestureController","handlers","bindings","domListeners","windowListeners","clean","cleanOnBind","_extends2","_mappedKeys$gestureKe","pinchState","coordinatesState","temp","handlerStart","_handler","handler","handlerEnd","_handler2","addRecognizer","recognizer","addEventBindings","eventNames","isArray","eventName","addDomTargetListeners","entries","push","substr","toLowerCase","getBindings","output","captureString","_ref3","fnsArray","bind","actions","Set","k","match","genuineHandlers","has","onDrag","onDragStart","onDragEnd","onScroll","onScrollStart","onScrollEnd","onWheel","onWheelStart","onWheelEnd","onMove","onMoveStart","onMoveEnd","onHover","GestureEvent","e","supportsGestureEvent","onPinch","onPinchStart","onPinchEnd","_ref4","gestureController","useRef","current","getDerivedHandlers","getDerivedConfig","useEffect","onAction","derivedHandlers","derivedConfig","realDomTarget"],"mappings":"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","file":"static/js/8.a668c54d.chunk.js","sourcesContent":["import defineProperty from \"./defineProperty\";\nexport default function _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    var ownKeys = Object.keys(source);\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(source, sym).enumerable;\n      }));\n    }\n\n    ownKeys.forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    });\n  }\n\n  return target;\n}","import React from 'react';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar GestureFlag;\n\n(function (GestureFlag) {\n  GestureFlag[\"OnStart\"] = \"start\";\n  GestureFlag[\"OnChange\"] = \"change\";\n  GestureFlag[\"OnEnd\"] = \"end\";\n})(GestureFlag || (GestureFlag = {})); // blank function\n\n\nvar noop = function noop() {}; // returns a function that chains all functions given as parameters\n\n\nvar chainFns = function chainFns() {\n  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {\n    fns[_key] = arguments[_key];\n  }\n\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return fns.forEach(function (fn) {\n      return fn.apply(void 0, args);\n    });\n  };\n}; // vector add\n\n\nvar addV = function addV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v + v2[i];\n  });\n}; // vector substract\n\n\nvar subV = function subV(v1, v2) {\n  return v1.map(function (v, i) {\n    return v - v2[i];\n  });\n};\n\nvar setListeners = function setListeners(add) {\n  return function (el, listeners, options) {\n    var action = add ? 'addEventListener' : 'removeEventListener';\n    listeners.forEach(function (_ref) {\n      var type = _ref[0],\n          fn = _ref[1];\n      return el[action](type, fn, options);\n    });\n  };\n};\n\nvar addListeners =\n/*#__PURE__*/\nsetListeners(true);\nvar removeListeners =\n/*#__PURE__*/\nsetListeners(false);\n/**\r\n * Gets modifier keys from event\r\n * @param event\r\n * @returns modifier keys\r\n */\n\nfunction getModifierKeys(event) {\n  var shiftKey = event.shiftKey,\n      altKey = event.altKey,\n      metaKey = event.metaKey,\n      ctrlKey = event.ctrlKey;\n  return {\n    shiftKey: shiftKey,\n    altKey: altKey,\n    metaKey: metaKey,\n    ctrlKey: ctrlKey\n  };\n}\n/**\r\n * Gets scroll event data\r\n * @param event\r\n * @returns scroll event data\r\n */\n\n\nfunction getScrollEventData(event) {\n  // If the currentTarget is the window then we return the scrollX/Y position.\n  // If not (ie the currentTarget is a DOM element), then we return scrollLeft/Top\n  var _event$currentTarget = event.currentTarget,\n      scrollX = _event$currentTarget.scrollX,\n      scrollY = _event$currentTarget.scrollY,\n      scrollLeft = _event$currentTarget.scrollLeft,\n      scrollTop = _event$currentTarget.scrollTop;\n  return _extends({\n    values: [scrollX || scrollLeft || 0, scrollY || scrollTop || 0]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets wheel event data\r\n * @param event\r\n * @returns wheel event data\r\n */\n\n\nfunction getWheelEventData(event) {\n  var deltaX = event.deltaX,\n      deltaY = event.deltaY; //TODO implement polyfill ?\n  // https://developer.mozilla.org/en-US/docs/Web/Events/wheel#Polyfill\n\n  return _extends({\n    values: [deltaX, deltaY]\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets pointer event data\r\n * @param event\r\n * @returns pointer event data\r\n */\n\n\nfunction getPointerEventData(event) {\n  var touches = event.touches,\n      buttons = event.buttons,\n      changedTouches = event.changedTouches;\n  var touchEvents = touches && touches.length > 0 ? touches : changedTouches && changedTouches.length > 0 ? changedTouches : null;\n\n  var _ref2 = touchEvents ? touchEvents[0] : event,\n      clientX = _ref2.clientX,\n      clientY = _ref2.clientY;\n\n  var down = touchEvents && touchEvents.length > 0 || buttons > 0;\n  return _extends({\n    values: [clientX, clientY],\n    touches: touchEvents && touchEvents.length || 0,\n    down: down,\n    buttons: buttons\n  }, getModifierKeys(event));\n}\n/**\r\n * Gets two touches event data\r\n * @param event\r\n * @returns two touches event data\r\n */\n\n\nfunction getTwoTouchesEventData(event) {\n  var touches = event.touches;\n  var dx = touches[1].clientX - touches[0].clientX;\n  var dy = touches[1].clientY - touches[0].clientY;\n  var da = [Math.hypot(dx, dy), -(Math.atan2(dx, dy) * 180) / Math.PI];\n  var origin = [(touches[1].clientX + touches[0].clientX) / 2, (touches[1].clientY + touches[0].clientY) / 2];\n  return _extends({\n    values: da,\n    origin: origin,\n    touches: 2,\n    down: touches.length > 0\n  }, getModifierKeys(event));\n}\n/**\r\n * Calculates velocity\r\n * @param diff the difference between current and previous vectors\r\n * @param delta_t the time delta\r\n * @param len the length of the diff vector\r\n * @returns velocity\r\n */\n\n\nfunction calculateVelocity(diff, delta_t, len) {\n  len = len || Math.hypot.apply(Math, diff);\n  return delta_t ? len / delta_t : 0;\n}\n/**\r\n * Calculates velocities vector\r\n * @template T the expected vector type\r\n * @param diff the previous value\r\n * @param delta_t the time delta\r\n * @returns velocities vector\r\n */\n\n\nfunction calculateVelocities(diff, delta_t) {\n  return delta_t ? diff.map(function (v) {\n    return v / delta_t;\n  }) : Array(diff.length).fill(0);\n}\n/**\r\n * Calculates distance\r\n * @param delta the difference between current and initial vectors\r\n * @returns distance\r\n */\n\n\nfunction calculateDistance(delta) {\n  return Math.hypot.apply(Math, delta);\n}\n/**\r\n * Calculates direction\r\n * @template T the expected vector type\r\n * @param diff\r\n * @param len\r\n * @returns direction\r\n */\n\n\nfunction calculateDirection(diff, len) {\n  len = len || Math.hypot.apply(Math, diff) || 1;\n  return diff.map(function (v) {\n    return v / len;\n  });\n}\n/**\r\n * Calculates all kinematics\r\n * @template T the expected vector type\r\n * @param delta the difference between current and initial vectors\r\n * @param diff the difference between current and previous vectors\r\n * @param delta_t the time delta between current and previous timestamps\r\n * @returns all kinematics\r\n */\n\n\nfunction calculateAllKinematics(delta, diff, delta_t) {\n  var len = Math.hypot.apply(Math, diff);\n  return {\n    velocities: calculateVelocities(diff, delta_t),\n    velocity: calculateVelocity(diff, delta_t, len),\n    distance: calculateDistance(delta),\n    direction: calculateDirection(diff, len)\n  };\n}\n/**\r\n * Whether the browser supports GestureEvent (ie Safari)\r\n * @returns true if the browser supports gesture event\r\n */\n\n\nfunction supportsGestureEvent() {\n  try {\n    // TODO [TS] possibly find GestureEvent definitions?\n    // @ts-ignore: Unreachable code error\n    return 'constructor' in GestureEvent;\n  } catch (e) {\n    return false;\n  }\n}\n/**\r\n * Some gestures might use the state key from another gesture (i.e. hover)\r\n * so mappedKeys is a commodity object to get the state key and handler key\r\n * for every gesture\r\n */\n\n\nvar mappedKeys = {\n  drag: {\n    stateKey: 'drag',\n    handlerKey: 'onDrag'\n  },\n  pinch: {\n    stateKey: 'pinch',\n    handlerKey: 'onPinch'\n  },\n  move: {\n    stateKey: 'move',\n    handlerKey: 'onMove'\n  },\n  scroll: {\n    stateKey: 'scroll',\n    handlerKey: 'onScroll'\n  },\n  wheel: {\n    stateKey: 'wheel',\n    handlerKey: 'onWheel'\n  },\n  hover: {\n    stateKey: 'move',\n    handlerKey: 'onHover'\n  }\n}; // default config (will extend user config)\n\nvar defaultConfig = {\n  domTarget: undefined,\n  event: {\n    passive: true,\n    capture: false\n  },\n  pointerEvents: false,\n  window: typeof window !== 'undefined' ? window : undefined,\n  transform: {\n    x: function x(_x) {\n      return _x;\n    },\n    y: function y(_y) {\n      return _y;\n    }\n  },\n  enabled: true,\n  drag: true,\n  pinch: true,\n  scroll: true,\n  wheel: true,\n  hover: true,\n  move: true\n}; // common initial state for all gestures\n\nvar initialCommon = {\n  event: undefined,\n  currentTarget: undefined,\n  pointerId: undefined,\n  values: [0, 0],\n  velocities: [0, 0],\n  delta: [0, 0],\n  initial: [0, 0],\n  previous: [0, 0],\n  transform: undefined,\n  local: [0, 0],\n  lastLocal: [0, 0],\n  first: false,\n  last: false,\n  active: false,\n  time: undefined,\n  cancel: noop,\n  canceled: false,\n  memo: undefined,\n  args: undefined\n}; // initial state for coordinates-based gestures\n\nvar initialCoordinates = {\n  xy: [0, 0],\n  vxvy: [0, 0],\n  velocity: 0,\n  distance: 0,\n  direction: [0, 0]\n}; // xy coordinates\n// initial state for distance and angle-based gestures (pinch)\n\nvar initialDistanceAngle = {\n  da: [0, 0],\n  vdva: [0, 0],\n  origin: [0, 0],\n  turns: 0\n}; // distance and angle\n// initial state object (used by the gesture controller)\n\nvar initialState = {\n  shared: {\n    hovering: false,\n    scrolling: false,\n    wheeling: false,\n    dragging: false,\n    moving: false,\n    pinching: false,\n    touches: 0,\n    buttons: 0,\n    down: false,\n    shiftKey: false,\n    altKey: false,\n    metaKey: false,\n    ctrlKey: false\n  },\n  move: _extends({}, initialCommon, {}, initialCoordinates),\n  drag: _extends({}, initialCommon, {}, initialCoordinates),\n  scroll: _extends({}, initialCommon, {}, initialCoordinates),\n  wheel: _extends({}, initialCommon, {}, initialCoordinates),\n  pinch: _extends({}, initialCommon, {}, initialDistanceAngle)\n}; // generic end state for all gestures\n\nvar genericEndState = {\n  first: false,\n  last: true,\n  active: false\n};\n/**\r\n * Recognizer abstract class\r\n * @template GestureType whether the Recognizer should deal with coordinates or distance / angle\r\n */\n\nvar Recognizer =\n/**\r\n * Creates an instance of a gesture recognizer.\r\n * @param gestureKey drag, move, hover, pinch, etc.\r\n * @param controller the controller attached to the gesture\r\n * @param [args] the args that should be passed to the gesture handler\r\n */\nfunction Recognizer(gestureKey, controller, args) {\n  var _this = this;\n\n  if (args === void 0) {\n    args = [];\n  }\n\n  this.gestureKey = gestureKey;\n  this.controller = controller;\n  this.args = args;\n\n  this.isEnabled = function () {\n    return _this.controller.config.enabled && _this.controller.config[_this.gestureKey];\n  }; // convenience method to set a timeout for a given gesture\n\n\n  this.setTimeout = function (callback, ms) {\n    var _window;\n\n    if (ms === void 0) {\n      ms = 140;\n    }\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    _this.controller.timeouts[_this.stateKey] = (_window = window).setTimeout.apply(_window, [callback, ms].concat(args));\n  }; // convenience method to clear a timeout for a given gesture\n\n\n  this.clearTimeout = function () {\n    clearTimeout(_this.controller.timeouts[_this.stateKey]);\n  }; // get the controller state for a given gesture\n\n\n  this.getState = function () {\n    return _this.controller.state[_this.stateKey];\n  }; // get the controller shared state\n\n\n  this.getSharedState = function () {\n    return _this.controller.state.shared;\n  }; // does the controller config has pointer events enabled\n\n\n  this.pointerEventsEnabled = function () {\n    return _this.controller.config.pointerEvents;\n  }; // gets the transform config of the controller\n\n\n  this.getTransformConfig = function () {\n    return _this.controller.config.transform;\n  }; // convenience method to add window listeners for a given gesture\n\n\n  this.addWindowListeners = function (listeners) {\n    _this.controller.addWindowListeners(_this.stateKey, listeners);\n  }; // convenience method to remove window listeners for a given gesture\n\n\n  this.removeWindowListeners = function () {\n    _this.controller.removeWindowListeners(_this.stateKey);\n  };\n  /**\r\n   * convenience method to update the controller state for a given gesture\r\n   * @param sharedState shared partial state object\r\n   * @param gestureState partial state object for the gesture handled by the recognizer\r\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\r\n   */\n\n\n  this.updateState = function (sharedState, gestureState, gestureFlag) {\n    _this.controller.updateState(sharedState, gestureState, _this.gestureKey, gestureFlag);\n  };\n  /**\r\n   * returns the start state for a given gesture\r\n   * @param values the values of the start state\r\n   * @param event the event that triggers the gesture start\r\n   */\n\n\n  this.getStartState = function (values, event) {\n    var state = _this.getState();\n\n    var initial = initialState[_this.stateKey];\n\n    var transform = state.transform || event.transform || _this.getTransformConfig();\n\n    var lastLocal = state.local || initial.local;\n    return _extends({}, initial, {\n      event: event,\n      values: values,\n      initial: values,\n      previous: values,\n      local: lastLocal,\n      lastLocal: lastLocal,\n      first: true,\n      active: true,\n      transform: transform,\n      time: event.timeStamp,\n      args: _this.args\n    });\n  }; // mapping this.stateKey to the state key the gesture handles\n  // (ie hover actually deals with the move gesture state)\n\n\n  this.stateKey = mappedKeys[gestureKey].stateKey;\n};\n/**\r\n * Abstract class for coordinates-based gesture recongizers\r\n */\n\n\nvar CoordinatesRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(CoordinatesRecognizer, _Recognizer);\n\n  function CoordinatesRecognizer() {\n    var _this;\n\n    _this = _Recognizer.apply(this, arguments) || this;\n    /**\r\n     * Utility function to get kinematics of the gesture\r\n     * @values values we want to calculate the kinematics from\r\n     * @event\r\n     * @returns set of values including delta, velocity, velocities, distance and direction\r\n     */\n\n    _this.getKinematics = function (values, event) {\n      // we get the gesture specific state\n      var state = _this.getState();\n\n      var xy = state.values,\n          initial = state.initial,\n          lastLocal = state.lastLocal,\n          _state$time = state.time,\n          time = _state$time === void 0 ? 0 : _state$time;\n\n      var transform = state.transform || event.transform || _this.getTransformConfig(); // delta is the difference between the current and initial value vectors\n\n\n      var delta = subV(values, initial).map(function (v, i) {\n        return Object.values(transform)[i](v);\n      }); // diff is the difference between the current and previous value vectors\n\n      var diff = subV(values, xy).map(function (v, i) {\n        return Object.values(transform)[i](v);\n      });\n      var delta_t = event.timeStamp - time;\n\n      var _calculateAllKinemati = calculateAllKinematics(delta, diff, delta_t),\n          velocity = _calculateAllKinemati.velocity,\n          velocities = _calculateAllKinemati.velocities,\n          distance = _calculateAllKinemati.distance,\n          direction = _calculateAllKinemati.direction;\n\n      return {\n        event: event,\n        values: values,\n        delta: delta,\n        velocity: velocity,\n        velocities: velocities,\n        distance: distance,\n        direction: direction,\n        local: addV(lastLocal, delta),\n        previous: xy,\n        transform: transform,\n        time: event.timeStamp\n      };\n    };\n\n    return _this;\n  }\n\n  return CoordinatesRecognizer;\n}(Recognizer);\n\nvar DragRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(DragRecognizer, _CoordinatesRecognize);\n\n  function DragRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'drag', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled()) return;\n\n      var _getPointerEventData = getPointerEventData(event),\n          values = _getPointerEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData, [\"values\"]); // making sure we're not dragging the element when more than one finger press the screen\n\n\n      if (rest.touches > 1) return;\n      var currentTarget = event.currentTarget,\n          pointerId = event.pointerId;\n\n      if (_this.pointerEventsEnabled()) {\n        // if pointers events\n        currentTarget && currentTarget.setPointerCapture(pointerId);\n      } else {\n        _this.removeWindowListeners();\n\n        var dragListeners = [['mousemove', _this.onChange], ['mouseup', _this.onEnd], ['touchmove', _this.onChange], ['touchend', _this.onEnd], ['touchcancel', _this.onEnd]];\n\n        _this.addWindowListeners(dragListeners);\n      }\n\n      var startState = _this.getStartState(values, event);\n\n      _this.updateState(_extends({}, rest, {\n        dragging: true,\n        down: true\n      }), _extends({}, startState, {\n        currentTarget: currentTarget,\n        pointerId: pointerId,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      }), GestureFlag.OnStart);\n    };\n\n    _this.onChange = function (event) {\n      var _this$getState = _this.getState(),\n          canceled = _this$getState.canceled,\n          active = _this$getState.active;\n\n      if (canceled || !active) return;\n\n      var _getPointerEventData2 = getPointerEventData(event),\n          values = _getPointerEventData2.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, [\"values\"]);\n\n      if (rest.buttons === 0 && rest.touches === 0) {\n        _this.onEnd(event);\n\n        return;\n      }\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var cancel = function cancel() {\n        return _this.onCancel(event);\n      };\n\n      _this.updateState(rest, _extends({}, kinematics, {\n        first: false,\n        cancel: cancel\n      }), GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      var state = _this.getState();\n\n      if (!state.active) return;\n      var currentTarget = state.currentTarget,\n          pointerId = state.pointerId;\n      if (currentTarget && _this.pointerEventsEnabled()) currentTarget.releasePointerCapture(pointerId);else _this.removeWindowListeners();\n\n      _this.updateState({\n        dragging: false,\n        down: false,\n        buttons: 0,\n        touches: 0\n      }, _extends({}, genericEndState, {\n        event: event\n      }), GestureFlag.OnEnd);\n    };\n\n    _this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = DragRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerDown', this.onStart], ['onPointerMove', this.onChange], [['onPointerUp', 'onPointerCancel'], this.onEnd]];\n    }\n\n    return [[['onMouseDown', 'onTouchStart'], this.onStart]];\n  };\n\n  return DragRecognizer;\n}(CoordinatesRecognizer);\n\nvar ScrollRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(ScrollRecognizer, _CoordinatesRecognize);\n\n  function ScrollRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'scroll', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getScrollEventData = getScrollEventData(event),\n          values = _getScrollEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getScrollEventData, [\"values\"]);\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState(values, event);\n\n        _this.updateState(_extends({\n          scrolling: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics(values, event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        scrolling: false\n      }, _extends({}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      }), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = ScrollRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onScroll', this.onChange]];\n  };\n\n  return ScrollRecognizer;\n}(CoordinatesRecognizer);\n\nvar WheelRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(WheelRecognizer, _CoordinatesRecognize);\n\n  function WheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'wheel', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getWheelEventData = getWheelEventData(event),\n          eventValues = _getWheelEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getWheelEventData, [\"values\"]);\n\n      var values = addV(eventValues, _this.getState().values);\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState(values, event);\n\n        _this.updateState(_extends({\n          wheeling: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics(values, event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        wheeling: false\n      }, _extends({}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      }), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = WheelRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onChange]];\n  };\n\n  return WheelRecognizer;\n}(CoordinatesRecognizer);\n\nvar MoveRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(MoveRecognizer, _CoordinatesRecognize);\n\n  function MoveRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'move', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled()) return;\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getPointerEventData = getPointerEventData(event),\n          values = _getPointerEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData, [\"values\"]);\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState(values, event);\n\n        _this.updateState(_extends({\n          moving: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics(values, event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        moving: false\n      }, _extends({}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      }), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = MoveRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerMove', this.onChange]];\n    }\n\n    return [['onMouseMove', this.onChange]];\n  };\n\n  return MoveRecognizer;\n}(CoordinatesRecognizer);\n\nvar HoverRecognizer =\n/*#__PURE__*/\nfunction (_CoordinatesRecognize) {\n  _inheritsLoose(HoverRecognizer, _CoordinatesRecognize);\n\n  function HoverRecognizer(controller, args) {\n    var _this;\n\n    _this = _CoordinatesRecognize.call(this, 'hover', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled()) return;\n\n      var _getPointerEventData = getPointerEventData(event),\n          values = _getPointerEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData, [\"values\"]);\n\n      _this.updateState(_extends({\n        hovering: true\n      }, rest), {\n        values: values,\n        event: event,\n        args: _this.args\n      }, GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      if (!_this.isEnabled()) return;\n\n      var _getPointerEventData2 = getPointerEventData(event),\n          values = _getPointerEventData2.values,\n          rest = _objectWithoutPropertiesLoose(_getPointerEventData2, [\"values\"]);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      _this.updateState(_extends({\n        hovering: false,\n        moving: false\n      }, rest), _extends({}, kinematics, {}, genericEndState, {\n        velocity: 0,\n        velocities: [0, 0]\n      })); // when the mouse leaves the element, we also fire the move handler\n      // without waiting for move to end with debounce\n\n\n      _this.controller.fireGestureHandler('move', GestureFlag.OnEnd);\n\n      _this.controller.fireGestureHandler('hover', GestureFlag.OnChange);\n    };\n\n    return _this;\n  }\n\n  var _proto = HoverRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    if (this.pointerEventsEnabled()) {\n      return [['onPointerEnter', this.onStart], ['onPointerLeave', this.onEnd]];\n    }\n\n    return [['onMouseEnter', this.onStart], ['onMouseLeave', this.onEnd]];\n  };\n\n  return HoverRecognizer;\n}(CoordinatesRecognizer);\n/**\r\n * Abstract class for distance/angle-based gesture recongizers\r\n */\n\n\nvar DistanceAngleRecognizer =\n/*#__PURE__*/\nfunction (_Recognizer) {\n  _inheritsLoose(DistanceAngleRecognizer, _Recognizer);\n\n  function DistanceAngleRecognizer() {\n    var _this;\n\n    _this = _Recognizer.apply(this, arguments) || this;\n    /**\r\n     * Utility function to get kinematics of the gesture\r\n     * @d distance\r\n     * @a angle\r\n     * @event\r\n     * @returns set of values including delta, velocities, turns\r\n     */\n\n    _this.getKinematics = function (_ref, event) {\n      var d = _ref[0],\n          a = _ref[1];\n\n      var state = _this.getState();\n\n      var da = state.values,\n          turns = state.turns,\n          initial = state.initial,\n          lastLocal = state.lastLocal,\n          _state$time = state.time,\n          time = _state$time === void 0 ? 0 : _state$time; // angle might not be defined when ctrl wheel is used for zoom only\n      // in that case we set it to the previous angle value\n\n      a = a === undefined ? da[1] : a;\n      var diff_d = d - da[0];\n      var diff_a = a - da[1];\n      /**\r\n       * The angle value might jump from 179deg to -179deg when we actually want to\r\n       * read 181deg to ensure continuity. To make that happen, we detect when the jump\r\n       * is supsiciously high (ie > 300deg) and increase the `turns` value\r\n       */\n\n      var newTurns = Math.abs(diff_a) > 300 ? turns + Math.sign(diff_a) : turns; // we update the angle difference to its corrected value\n\n      diff_a -= 360 * newTurns;\n      var delta_d = d - initial[0];\n      var delta_a = a - 360 * newTurns - initial[1];\n      var delta = [delta_d, delta_a];\n      var delta_t = event.timeStamp - time;\n      var velocities = calculateVelocities([diff_d, diff_a], delta_t);\n      return {\n        event: event,\n        values: [d, a],\n        delta: delta,\n        velocities: velocities,\n        turns: newTurns,\n        local: addV(lastLocal, delta),\n        previous: da,\n        time: event.timeStamp\n      };\n    };\n\n    return _this;\n  }\n\n  return DistanceAngleRecognizer;\n}(Recognizer);\n\nvar PinchRecognizer =\n/*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchRecognizer, _DistanceAngleRecogni);\n\n  function PinchRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled() || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa.values,\n          origin = _getTwoTouchesEventDa.origin,\n          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa, [\"values\", \"origin\"]);\n\n      var startState = _this.getStartState(values, event);\n\n      _this.updateState(_extends({}, rest, {\n        pinching: true,\n        down: true\n      }), _extends({}, startState, {\n        origin: origin,\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      }), GestureFlag.OnStart);\n    };\n\n    _this.onChange = function (event) {\n      var _this$getState = _this.getState(),\n          canceled = _this$getState.canceled,\n          active = _this$getState.active;\n\n      if (canceled || !active || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa2 = getTwoTouchesEventData(event),\n          values = _getTwoTouchesEventDa2.values,\n          origin = _getTwoTouchesEventDa2.origin,\n          rest = _objectWithoutPropertiesLoose(_getTwoTouchesEventDa2, [\"values\", \"origin\"]);\n\n      var kinematics = _this.getKinematics(values, event);\n\n      var cancel = function cancel() {\n        return _this.onCancel(event);\n      };\n\n      _this.updateState(rest, _extends({}, kinematics, {\n        origin: origin,\n        first: false,\n        cancel: cancel\n      }), GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        pinching: false,\n        down: false,\n        touches: 0\n      }, _extends({}, genericEndState, {\n        event: event\n      }), GestureFlag.OnEnd);\n    };\n\n    _this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onTouchStart', this.onStart], ['onTouchMove', this.onChange], [['onTouchEnd', 'onTouchCancel'], this.onEnd]];\n  };\n\n  return PinchRecognizer;\n}(DistanceAngleRecognizer);\n\nvar PinchWheelRecognizer =\n/*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWheelRecognizer, _DistanceAngleRecogni);\n\n  function PinchWheelRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n\n    _this.onChange = function (event) {\n      if (!_this.isEnabled() || !event.ctrlKey) return;\n      event.preventDefault();\n\n      _this.clearTimeout();\n\n      _this.setTimeout(_this.onEnd);\n\n      var _getWheelEventData = getWheelEventData(event),\n          values = _getWheelEventData.values,\n          rest = _objectWithoutPropertiesLoose(_getWheelEventData, [\"values\"]);\n\n      var d = _this.getState().values[0] - values[1];\n\n      if (!_this.getState().active) {\n        var startState = _this.getStartState([d, 0], event);\n\n        _this.updateState(_extends({\n          pinching: true\n        }, rest), startState, GestureFlag.OnStart);\n      } else {\n        var kinematics = _this.getKinematics([d, undefined], event);\n\n        _this.updateState(rest, _extends({}, kinematics, {\n          first: false\n        }), GestureFlag.OnChange);\n      }\n    };\n\n    _this.onEnd = function () {\n      if (!_this.getState().active) return;\n\n      _this.updateState({\n        pinching: false,\n        down: false,\n        touches: 0\n      }, _extends({}, genericEndState), GestureFlag.OnEnd);\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchWheelRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onWheel', this.onChange]];\n  };\n\n  return PinchWheelRecognizer;\n}(DistanceAngleRecognizer);\n\nvar SCALE_FACTOR = 260;\n\nvar PinchWebKitGestureRecognizer =\n/*#__PURE__*/\nfunction (_DistanceAngleRecogni) {\n  _inheritsLoose(PinchWebKitGestureRecognizer, _DistanceAngleRecogni);\n\n  function PinchWebKitGestureRecognizer(controller, args) {\n    var _this;\n\n    _this = _DistanceAngleRecogni.call(this, 'pinch', controller, args) || this;\n\n    _this.onStart = function (event) {\n      if (!_this.isEnabled()) return;\n      event.preventDefault();\n      var da = [event.scale * SCALE_FACTOR, event.rotation];\n\n      var startState = _this.getStartState(da, event);\n\n      _this.updateState({\n        pinching: true,\n        down: true,\n        touches: 2\n      }, _extends({}, startState, {\n        cancel: function cancel() {\n          return _this.onCancel(event);\n        }\n      }), GestureFlag.OnStart);\n    };\n\n    _this.onChange = function (event) {\n      var _this$getState = _this.getState(),\n          canceled = _this$getState.canceled,\n          active = _this$getState.active;\n\n      if (canceled || !active) return;\n      event.preventDefault();\n      var da = [event.scale * SCALE_FACTOR, event.rotation];\n\n      var kinematics = _this.getKinematics(da, event);\n\n      var cancel = function cancel() {\n        return _this.onCancel(event);\n      };\n\n      _this.updateState(null, _extends({}, kinematics, {\n        first: false,\n        cancel: cancel\n      }), GestureFlag.OnChange);\n    };\n\n    _this.onEnd = function (event) {\n      if (!_this.getState().active) return;\n      event.preventDefault();\n\n      _this.updateState({\n        pinching: false,\n        down: false,\n        touches: 0\n      }, _extends({}, genericEndState, {\n        event: event\n      }), GestureFlag.OnEnd);\n    };\n\n    _this.onCancel = function (event) {\n      _this.updateState(null, {\n        canceled: true,\n        cancel: noop\n      });\n\n      requestAnimationFrame(function () {\n        return _this.onEnd(event);\n      });\n    };\n\n    _this.updateTouchData = function (event) {\n      if (!_this.isEnabled() || event.touches.length !== 2) return;\n\n      var _getTwoTouchesEventDa = getTwoTouchesEventData(event),\n          origin = _getTwoTouchesEventDa.origin;\n\n      _this.updateState(null, {\n        origin: origin\n      });\n    };\n\n    return _this;\n  }\n\n  var _proto = PinchWebKitGestureRecognizer.prototype;\n\n  _proto.getEventBindings = function getEventBindings() {\n    return [['onGestureStart', this.onStart], ['onGestureChange', this.onChange], [['onGestureEnd', 'onTouchCancel'], this.onEnd], [['onTouchStart', 'onTouchMove'], this.updateTouchData]];\n  };\n\n  return PinchWebKitGestureRecognizer;\n}(DistanceAngleRecognizer);\n/**\r\n * Gesture controller will create gesture recognizers (which handle the gesture logic)\r\n * and keep track of the state for all gestures\r\n *\r\n * @template BinderType the type the bind function should return\r\n */\n\n\nvar GestureController = function GestureController(handlers, config) {\n  var _this = this;\n\n  this.handlers = handlers;\n  this.config = config;\n  this.state = initialState; // state for all gestures\n\n  this.timeouts = {}; // keeping track of timeouts for debounced gestures (such as move, scroll, wheel)\n\n  this.bindings = {}; // an object holding the handlers associated to the gestures\n\n  this.domListeners = []; // when config.domTarget is set, we attach events directly to the dom\n\n  this.windowListeners = {}; // keeps track of window listeners added by gestures (drag only at the moment)\n\n  /**\r\n   * Function run on component unmount\r\n   * Cleans timeouts and removes dom listeners set by the bind function\r\n   */\n\n  this.clean = function () {\n    _this.cleanOnBind();\n\n    Object.values(_this.timeouts).forEach(clearTimeout);\n    Object.keys(_this.windowListeners).forEach(function (stateKey) {\n      return _this.removeWindowListeners(stateKey);\n    });\n  };\n  /**\r\n   * Function run every time the bind function is run (ie on every render)\r\n   * Reset the binding object and remove dom listeners attached to config.domTarget\r\n   */\n\n\n  this.cleanOnBind = function () {\n    _this.bindings = {};\n    var domTarget = _this.config.domTarget;\n\n    if (domTarget) {\n      removeListeners(domTarget, _this.domListeners, _this.config.event);\n      _this.domListeners = [];\n    }\n  };\n  /**\r\n   * Commodity function to let gesture recognizer update global state\r\n   * @param sharedState shared partial state object\r\n   * @param gestureState partial gesture specific state object\r\n   * @param gestureKey the gesture key ('drag', 'move'...)\r\n   * @param [gestureFlag] if set, will also fire the gesture handler set by the user\r\n   */\n\n\n  this.updateState = function (sharedState, gestureState, gestureKey, gestureFlag) {\n    var _extends2;\n\n    var stateKey = mappedKeys[gestureKey].stateKey;\n    _this.state = _extends({}, _this.state, (_extends2 = {\n      shared: _extends({}, _this.state.shared, {}, sharedState)\n    }, _extends2[stateKey] = _extends({}, _this.state[stateKey], {}, gestureState), _extends2));\n\n    if (gestureFlag) {\n      _this.fireGestureHandler(gestureKey, gestureFlag);\n    }\n  }; // fire the gesture handler defined by the user\n\n\n  this.fireGestureHandler = function (gestureKey, gestureFlag) {\n    // gets the state key and handler key from the gesture key\n    // gestureKey: 'hover' -> stateKey: 'move', handlerKey: 'onHover'\n    var _mappedKeys$gestureKe = mappedKeys[gestureKey],\n        stateKey = _mappedKeys$gestureKe.stateKey,\n        handlerKey = _mappedKeys$gestureKe.handlerKey;\n\n    var state = _extends({}, _this.state.shared, {}, _this.state[stateKey]);\n\n    if (gestureKey === 'pinch') {\n      var pinchState = state;\n      pinchState.da = state.values; // legacy state attribute for pinch gestures\n\n      pinchState.vdva = state.velocities; // legacy state attribute for pinch gestures\n    } else {\n      var coordinatesState = state;\n      coordinatesState.xy = state.values; // legacy state attribute for xy gestures\n\n      coordinatesState.vxvy = state.velocities; // legacy state attribute for xy gestures\n    } // TODO to be removed in future versions\n\n\n    state.temp = state.memo; // legacy temp attribute\n\n    if (gestureFlag === GestureFlag.OnStart) {\n      var handlerStart = handlerKey + \"Start\";\n      var _handler = _this.handlers[handlerStart];\n      _handler && _handler(state);\n    } // whenever a flag is set, we run the default on[Gesture] function\n    // i.e. GestureFlag.OnStart would trigger both onDragStart and onDrag\n\n\n    var handler = _this.handlers[handlerKey];\n\n    if (handler) {\n      _this.state[stateKey].memo = handler(state) || _this.state[stateKey].memo;\n    }\n\n    if (gestureFlag === GestureFlag.OnEnd) {\n      var handlerEnd = handlerKey + \"End\";\n      var _handler2 = _this.handlers[handlerEnd];\n      _handler2 && _handler2(state);\n    }\n  };\n  /**\r\n   * Commodity function to let recognizers simply add listeners to config.window\r\n   * @param stateKey\r\n   * @param listeners\r\n   */\n\n\n  this.addWindowListeners = function (stateKey, listeners) {\n    if (!_this.config.window) return; // we use this.windowListeners to keep track of the listeners we add\n\n    _this.windowListeners[stateKey] = listeners;\n    addListeners(_this.config.window, listeners, _this.config.event);\n  }; // commodity function to let recognizers simply remove listeners from config.window\n\n\n  this.removeWindowListeners = function (stateKey) {\n    if (!_this.config.window) return;\n    var listeners = _this.windowListeners[stateKey];\n\n    if (listeners) {\n      removeListeners(_this.config.window, listeners, _this.config.event);\n      delete _this.windowListeners[stateKey];\n    }\n  };\n  /**\r\n   * Adds a recognizer to this.bindings\r\n   * @param recognizer\r\n   */\n\n\n  this.addRecognizer = function (recognizer) {\n    recognizer.getEventBindings().map(_this.addEventBindings);\n  };\n  /**\r\n   * this.bindings is an object which keys match ReactEventHandlerKeys (onMouseMove, onTouchStart...).\r\n   * Since a recognizer might want to bind a handler function to an event key already used by a previously\r\n   * added recognizer, we need to make sure that each event key is an array of all the functions mapped for\r\n   * that key.\r\n   */\n\n\n  this.addEventBindings = function (_ref) {\n    var eventNames = _ref[0],\n        fn = _ref[1];\n    var eventNamesArray = !Array.isArray(eventNames) ? [eventNames] : eventNames;\n    eventNamesArray.forEach(function (eventName) {\n      _this.bindings[eventName] = _this.bindings[eventName] ? [].concat(_this.bindings[eventName], [fn]) : [fn];\n    });\n  };\n  /**\r\n   * When config.domTarget is set, this function will add dom listeners to it\r\n   */\n\n\n  this.addDomTargetListeners = function () {\n    var domTarget = _this.config.domTarget; // we iterate on the entries of this.binding\n    // for each event, we chain the array of functions mapped to it\n    // and push it to this.domListeners\n\n    Object.entries(_this.bindings).forEach(function (_ref2) {\n      var event = _ref2[0],\n          fns = _ref2[1];\n\n      _this.domListeners.push([event.substr(2).toLowerCase(), chainFns.apply(void 0, fns)]);\n    });\n    addListeners(domTarget, _this.domListeners, _this.config.event);\n  };\n  /**\r\n   * getBindings will return an object that will be bound by users\r\n   * to the react component they want to interact with\r\n   */\n\n\n  this.getBindings = function () {\n    var output = {};\n    var captureString = _this.config.event.capture ? 'Capture' : '';\n    Object.entries(_this.bindings).forEach(function (_ref3) {\n      var event = _ref3[0],\n          fns = _ref3[1];\n      var fnsArray = Array.isArray(fns) ? fns : [fns];\n      var key = event + captureString;\n      output[key] = chainFns.apply(void 0, fnsArray);\n    });\n    return output;\n  };\n\n  this.bind = function () {\n    // if handlers contains {onDragStart, onDrag, onDragEnd, onMoveStart, onMove}\n    // actions will skip on[Gesture][\"Start\"|\"End\"] functions and include\n    // ['onDrag', 'onMove']\n    var actions = new Set(Object.keys(_this.handlers).filter(function (k) {\n      return k.indexOf('on') === 0;\n    }).map(function (k) {\n      var match = k.match(/(on[A-Z][a-z]+)/);\n      return match ? match[1] : undefined;\n    }));\n    var domTarget = _this.config.domTarget;\n\n    var genuineHandlers = _extends({}, _this.handlers); // cleaning before adding\n\n\n    _this.cleanOnBind();\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (actions.has('onDrag')) {\n      _this.addRecognizer(new DragRecognizer(_this, args));\n\n      delete genuineHandlers.onDrag;\n      delete genuineHandlers.onDragStart;\n      delete genuineHandlers.onDragEnd;\n    }\n\n    if (actions.has('onScroll')) {\n      _this.addRecognizer(new ScrollRecognizer(_this, args));\n\n      delete genuineHandlers.onScroll;\n      delete genuineHandlers.onScrollStart;\n      delete genuineHandlers.onScrollEnd;\n    }\n\n    if (actions.has('onWheel')) {\n      _this.addRecognizer(new WheelRecognizer(_this, args));\n\n      delete genuineHandlers.onWheel;\n      delete genuineHandlers.onWheelStart;\n      delete genuineHandlers.onWheelEnd;\n    }\n\n    if (actions.has('onMove')) {\n      _this.addRecognizer(new MoveRecognizer(_this, args));\n\n      delete genuineHandlers.onMove;\n      delete genuineHandlers.onMoveStart;\n      delete genuineHandlers.onMoveEnd;\n    }\n\n    if (actions.has('onHover')) {\n      _this.addRecognizer(new HoverRecognizer(_this, args));\n\n      delete genuineHandlers.onHover;\n    }\n\n    if (actions.has('onPinch')) {\n      // since react doesn't have handlers for gesture events we can only use them\n      // domTarget is set (and when the browser supprots them).\n      if (domTarget && supportsGestureEvent()) {\n        _this.addRecognizer(new PinchWebKitGestureRecognizer(_this, args));\n      } else {\n        _this.addRecognizer(new PinchRecognizer(_this, args));\n\n        _this.addRecognizer(new PinchWheelRecognizer(_this, args));\n      }\n\n      delete genuineHandlers.onPinch;\n      delete genuineHandlers.onPinchStart;\n      delete genuineHandlers.onPinchEnd;\n    } // we also add event bindings for genuine handlers\n\n\n    Object.entries(genuineHandlers).map(function (_ref4) {\n      var event = _ref4[0],\n          fn = _ref4[1]; // we're cheating when it comes to event type :(\n\n      _this.addEventBindings([event, fn]);\n    }); // if config.domTarget is set we add event listeners to it and return the clean function\n\n    if (domTarget) {\n      _this.addDomTargetListeners();\n\n      return _this.clean;\n    } // if not, we return an object that contains gesture handlers mapped to react handler event keys\n\n\n    return _this.getBindings();\n  };\n};\n\nfunction useGesture(handlers, config) {\n  // the gesture controller will keep track of all gesture states\n  var gestureController = React.useRef();\n\n  if (!gestureController.current) {\n    // we initialize the gesture controller once\n    gestureController.current = new GestureController(getDerivedHandlers(handlers), getDerivedConfig(config));\n  }\n\n  React.useEffect(function () {\n    // every time handlers or config change, we let the gesture controller compute\n    // them so that the gesture handlers functions are aware of the changes\n    gestureController.current.config = getDerivedConfig(config);\n    gestureController.current.handlers = getDerivedHandlers(handlers);\n  }, [handlers, config]); // when the user component unmounts, we run our gesture controller clean function\n\n  React.useEffect(function () {\n    return gestureController.current.clean;\n  }, []); // we return the bind function of our controller, which returns an binding object or\n  // a cleaning function depending on whether config.domTarget is set\n\n  return gestureController.current.bind;\n}\n/* SHORTHAND HANDLERS */\n\n\nvar useDrag = function useDrag(handler, config) {\n  return useGesture({\n    onDrag: handler\n  }, config);\n};\n\nvar useMove = function useMove(handler, config) {\n  return useGesture({\n    onMove: handler\n  }, config);\n};\n\nvar useHover = function useHover(handler, config) {\n  return useGesture({\n    onHover: handler\n  }, config);\n};\n\nvar useScroll = function useScroll(handler, config) {\n  return useGesture({\n    onScroll: handler\n  }, config);\n};\n\nvar useWheel = function useWheel(handler, config) {\n  return useGesture({\n    onWheel: handler\n  }, config);\n};\n\nvar usePinch = function usePinch(handler, config) {\n  return useGesture({\n    onPinch: handler\n  }, config);\n};\n\nfunction getDerivedHandlers(handlers) {\n  if (typeof handlers === 'function') return {\n    onDrag: handlers\n  };\n\n  var onAction = handlers.onAction,\n      rest = _objectWithoutPropertiesLoose(handlers, [\"onAction\"]);\n\n  var derivedHandlers = rest;\n  if (onAction) derivedHandlers.onDrag = onAction;\n  return derivedHandlers;\n}\n\nfunction getDerivedConfig(config) {\n  var derivedConfig = _extends({}, defaultConfig, {}, config);\n\n  var domTarget = derivedConfig.domTarget;\n  var realDomTarget = domTarget && 'current' in domTarget ? domTarget.current : domTarget;\n  derivedConfig.domTarget = realDomTarget;\n  return derivedConfig;\n}\n\nexport { useDrag, useGesture, useHover, useMove, usePinch, useScroll, useWheel };"],"sourceRoot":""}